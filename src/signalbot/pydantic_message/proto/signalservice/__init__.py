# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: SignalService.proto
# plugin: python-betterproto2
# This file has been @generated

__all__ = (
    "AddressableMessage",
    "AttachmentPointer",
    "AttachmentPointerFlags",
    "BodyRange",
    "BodyRangeStyle",
    "CallMessage",
    "CallMessageAnswer",
    "CallMessageBusy",
    "CallMessageHangup",
    "CallMessageHangupType",
    "CallMessageIceUpdate",
    "CallMessageOffer",
    "CallMessageOfferType",
    "CallMessageOpaque",
    "CallMessageOpaqueUrgency",
    "ContactDetails",
    "ContactDetailsAvatar",
    "Content",
    "ConversationIdentifier",
    "DataMessage",
    "DataMessageAdminDelete",
    "DataMessageContact",
    "DataMessageContactAvatar",
    "DataMessageContactEmail",
    "DataMessageContactEmailType",
    "DataMessageContactName",
    "DataMessageContactPhone",
    "DataMessageContactPhoneType",
    "DataMessageContactPostalAddress",
    "DataMessageContactPostalAddressType",
    "DataMessageDelete",
    "DataMessageFlags",
    "DataMessageGiftBadge",
    "DataMessageGroupCallUpdate",
    "DataMessagePayment",
    "DataMessagePaymentActivation",
    "DataMessagePaymentActivationType",
    "DataMessagePaymentAmount",
    "DataMessagePaymentAmountMobileCoin",
    "DataMessagePaymentNotification",
    "DataMessagePaymentNotificationMobileCoin",
    "DataMessagePinMessage",
    "DataMessagePollCreate",
    "DataMessagePollTerminate",
    "DataMessagePollVote",
    "DataMessageProtocolVersion",
    "DataMessageQuote",
    "DataMessageQuoteQuotedAttachment",
    "DataMessageQuoteType",
    "DataMessageReaction",
    "DataMessageSticker",
    "DataMessageStoryContext",
    "DataMessageUnpinMessage",
    "DecryptionErrorMessage",
    "EditMessage",
    "Envelope",
    "EnvelopeType",
    "GroupContext",
    "GroupContextMember",
    "GroupContextType",
    "GroupContextV2",
    "NullMessage",
    "PaymentAddress",
    "PaymentAddressMobileCoin",
    "PniSignatureMessage",
    "Preview",
    "ReceiptMessage",
    "ReceiptMessageType",
    "StoryMessage",
    "SyncMessage",
    "SyncMessageAttachmentBackfillRequest",
    "SyncMessageAttachmentBackfillResponse",
    "SyncMessageAttachmentBackfillResponseAttachmentData",
    "SyncMessageAttachmentBackfillResponseAttachmentDataList",
    "SyncMessageAttachmentBackfillResponseAttachmentDataStatus",
    "SyncMessageAttachmentBackfillResponseError",
    "SyncMessageBlocked",
    "SyncMessageCallEvent",
    "SyncMessageCallEventDirection",
    "SyncMessageCallEventEvent",
    "SyncMessageCallEventType",
    "SyncMessageCallLinkUpdate",
    "SyncMessageCallLinkUpdateType",
    "SyncMessageCallLogEvent",
    "SyncMessageCallLogEventType",
    "SyncMessageConfiguration",
    "SyncMessageContacts",
    "SyncMessageDeleteForMe",
    "SyncMessageDeleteForMeAttachmentDelete",
    "SyncMessageDeleteForMeConversationDelete",
    "SyncMessageDeleteForMeLocalOnlyConversationDelete",
    "SyncMessageDeleteForMeMessageDeletes",
    "SyncMessageDeviceNameChange",
    "SyncMessageFetchLatest",
    "SyncMessageFetchLatestType",
    "SyncMessageGroups",
    "SyncMessageKeys",
    "SyncMessageMessageRequestResponse",
    "SyncMessageMessageRequestResponseType",
    "SyncMessageOutgoingPayment",
    "SyncMessageOutgoingPaymentMobileCoin",
    "SyncMessagePniChangeNumber",
    "SyncMessagePniIdentity",
    "SyncMessageRead",
    "SyncMessageRequest",
    "SyncMessageRequestType",
    "SyncMessageSent",
    "SyncMessageSentStoryMessageRecipient",
    "SyncMessageSentUnidentifiedDeliveryStatus",
    "SyncMessageStickerPackOperation",
    "SyncMessageStickerPackOperationType",
    "SyncMessageViewOnceOpen",
    "SyncMessageViewed",
    "TextAttachment",
    "TextAttachmentGradient",
    "TextAttachmentStyle",
    "TypingMessage",
    "TypingMessageAction",
    "Verified",
    "VerifiedState",
)

import typing

import betterproto2
import pydantic
from pydantic import model_validator
from pydantic.dataclasses import dataclass

from ..message_pool import default_message_pool

_COMPILER_VERSION = "0.9.0"
betterproto2.check_compiler_version(_COMPILER_VERSION)


class AttachmentPointerFlags(betterproto2.Enum):
    VOICE_MESSAGE = 1

    BORDERLESS = 2

    GIF = 8


class BodyRangeStyle(betterproto2.Enum):
    NONE = 0

    BOLD = 1

    ITALIC = 2

    SPOILER = 3

    STRIKETHROUGH = 4

    MONOSPACE = 5


class CallMessageHangupType(betterproto2.Enum):
    HANGUP_NORMAL = 0

    HANGUP_ACCEPTED = 1

    HANGUP_DECLINED = 2

    HANGUP_BUSY = 3

    HANGUP_NEED_PERMISSION = 4


class CallMessageOfferType(betterproto2.Enum):
    OFFER_AUDIO_CALL = 0

    OFFER_VIDEO_CALL = 1


class CallMessageOpaqueUrgency(betterproto2.Enum):
    DROPPABLE = 0

    HANDLE_IMMEDIATELY = 1


class DataMessageContactEmailType(betterproto2.Enum):
    HOME = 1

    MOBILE = 2

    WORK = 3

    CUSTOM = 4


class DataMessageContactPhoneType(betterproto2.Enum):
    HOME = 1

    MOBILE = 2

    WORK = 3

    CUSTOM = 4


class DataMessageContactPostalAddressType(betterproto2.Enum):
    HOME = 1

    WORK = 2

    CUSTOM = 3


class DataMessageFlags(betterproto2.Enum):
    END_SESSION = 1

    EXPIRATION_TIMER_UPDATE = 2

    PROFILE_KEY_UPDATE = 4

    FORWARD = 8


class DataMessagePaymentActivationType(betterproto2.Enum):
    REQUEST = 0

    ACTIVATED = 1


class DataMessageProtocolVersion(betterproto2.Enum):
    INITIAL = 0

    MESSAGE_TIMERS = 1

    VIEW_ONCE = 2

    VIEW_ONCE_VIDEO = 3

    REACTIONS = 4

    CDN_SELECTOR_ATTACHMENTS = 5

    MENTIONS = 6

    PAYMENTS = 7

    POLLS = 8

    CURRENT = 8


class DataMessageQuoteType(betterproto2.Enum):
    NORMAL = 0

    GIFT_BADGE = 1

    POLL = 2


class EnvelopeType(betterproto2.Enum):
    UNKNOWN = 0

    CIPHERTEXT = 1
    """
    content => (version byte | SignalMessage{Content})
    """

    PREKEY_BUNDLE = 3
    """
    content => (version byte | PreKeySignalMessage{Content})
    """

    SERVER_DELIVERY_RECEIPT = 5
    """
    legacyMessage => [] AND content => []
    """

    UNIDENTIFIED_SENDER = 6
    """
    legacyMessage => [] AND content => ((version byte | UnidentifiedSenderMessage) OR (version byte | Multi-Recipient Sealed Sender Format))
    """

    SENDERKEY_MESSAGE = 7
    """
    legacyMessage => [] AND content => (version byte | SenderKeyMessage)
    """

    PLAINTEXT_CONTENT = 8
    """
    legacyMessage => [] AND content => (marker byte | Content)
    """


class GroupContextType(betterproto2.Enum):
    UNKNOWN = 0

    UPDATE = 1

    DELIVER = 2

    QUIT = 3

    REQUEST_INFO = 4


class ReceiptMessageType(betterproto2.Enum):
    DELIVERY = 0

    READ = 1

    VIEWED = 2


class SyncMessageAttachmentBackfillResponseAttachmentDataStatus(betterproto2.Enum):
    PENDING = 0

    TERMINAL_ERROR = 1


class SyncMessageAttachmentBackfillResponseError(betterproto2.Enum):
    MESSAGE_NOT_FOUND = 0


class SyncMessageCallEventDirection(betterproto2.Enum):
    UNKNOWN_DIRECTION = 0

    INCOMING = 1

    OUTGOING = 2


class SyncMessageCallEventEvent(betterproto2.Enum):
    UNKNOWN_EVENT = 0

    ACCEPTED = 1

    NOT_ACCEPTED = 2

    DELETE = 3

    OBSERVED = 4


class SyncMessageCallEventType(betterproto2.Enum):
    UNKNOWN_TYPE = 0

    AUDIO_CALL = 1

    VIDEO_CALL = 2

    GROUP_CALL = 3

    AD_HOC_CALL = 4


class SyncMessageCallLinkUpdateType(betterproto2.Enum):
    UPDATE = 0


class SyncMessageCallLogEventType(betterproto2.Enum):
    CLEAR = 0

    MARKED_AS_READ = 1

    MARKED_AS_READ_IN_CONVERSATION = 2

    CLEAR_IN_CONVERSATION = 3


class SyncMessageFetchLatestType(betterproto2.Enum):
    UNKNOWN = 0

    LOCAL_PROFILE = 1

    STORAGE_MANIFEST = 2

    SUBSCRIPTION_STATUS = 3


class SyncMessageMessageRequestResponseType(betterproto2.Enum):
    UNKNOWN = 0

    ACCEPT = 1

    DELETE = 2

    BLOCK = 3

    BLOCK_AND_DELETE = 4

    SPAM = 5

    BLOCK_AND_SPAM = 6


class SyncMessageRequestType(betterproto2.Enum):
    UNKNOWN = 0

    CONTACTS = 1

    GROUPS = 2

    BLOCKED = 3

    CONFIGURATION = 4

    KEYS = 5


class SyncMessageStickerPackOperationType(betterproto2.Enum):
    INSTALL = 0

    REMOVE = 1


class TextAttachmentStyle(betterproto2.Enum):
    DEFAULT = 0

    REGULAR = 1

    BOLD = 2

    SERIF = 3

    SCRIPT = 4

    CONDENSED = 5


class TypingMessageAction(betterproto2.Enum):
    STARTED = 0

    STOPPED = 1


class VerifiedState(betterproto2.Enum):
    DEFAULT = 0

    VERIFIED = 1

    UNVERIFIED = 2


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class AddressableMessage(betterproto2.Message):
    """


    Oneofs:
        - author:
    """

    author_service_id: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)] | None" = betterproto2.field(
        1, betterproto2.TYPE_STRING, optional=True, group="author"
    )

    author_e_164: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)] | None" = betterproto2.field(
        2, betterproto2.TYPE_STRING, optional=True, group="author"
    )

    author_service_id_binary: "bytes | None" = betterproto2.field(
        4, betterproto2.TYPE_BYTES, optional=True, group="author"
    )
    """
    service ID binary (i.e. 16 byte UUID for ACI, 1 byte prefix + 16 byte UUID for PNI)
    """

    sent_timestamp: "typing.Annotated[int, pydantic.Field(ge=0, le=2**64 - 1)]" = (
        betterproto2.field(3, betterproto2.TYPE_UINT64)
    )

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "signalservice", "AddressableMessage", AddressableMessage
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class AttachmentPointer(betterproto2.Message):
    """


    Oneofs:
        - attachment_identifier:
    """

    cdn_id: "typing.Annotated[int, pydantic.Field(ge=0, le=2**64 - 1)] | None" = (
        betterproto2.field(
            1, betterproto2.TYPE_FIXED64, optional=True, group="attachment_identifier"
        )
    )

    cdn_key: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)] | None" = betterproto2.field(
        15, betterproto2.TYPE_STRING, optional=True, group="attachment_identifier"
    )

    client_uuid: "bytes" = betterproto2.field(20, betterproto2.TYPE_BYTES)
    """
    Cross-client identifier for this attachment among all attachments on the
    owning message.
    """

    content_type: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        2, betterproto2.TYPE_STRING
    )

    key: "bytes" = betterproto2.field(3, betterproto2.TYPE_BYTES)

    size: "typing.Annotated[int, pydantic.Field(ge=0, le=2**32 - 1)]" = (
        betterproto2.field(4, betterproto2.TYPE_UINT32)
    )

    thumbnail: "bytes" = betterproto2.field(5, betterproto2.TYPE_BYTES)

    digest: "bytes" = betterproto2.field(6, betterproto2.TYPE_BYTES)

    incremental_mac: "bytes" = betterproto2.field(19, betterproto2.TYPE_BYTES)

    chunk_size: "typing.Annotated[int, pydantic.Field(ge=0, le=2**32 - 1)]" = (
        betterproto2.field(17, betterproto2.TYPE_UINT32)
    )

    file_name: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        7, betterproto2.TYPE_STRING
    )

    flags: "typing.Annotated[int, pydantic.Field(ge=0, le=2**32 - 1)]" = (
        betterproto2.field(8, betterproto2.TYPE_UINT32)
    )

    width: "typing.Annotated[int, pydantic.Field(ge=0, le=2**32 - 1)]" = (
        betterproto2.field(9, betterproto2.TYPE_UINT32)
    )

    height: "typing.Annotated[int, pydantic.Field(ge=0, le=2**32 - 1)]" = (
        betterproto2.field(10, betterproto2.TYPE_UINT32)
    )

    caption: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        11, betterproto2.TYPE_STRING
    )

    blur_hash: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        12, betterproto2.TYPE_STRING
    )

    upload_timestamp: "typing.Annotated[int, pydantic.Field(ge=0, le=2**64 - 1)]" = (
        betterproto2.field(13, betterproto2.TYPE_UINT64)
    )

    cdn_number: "typing.Annotated[int, pydantic.Field(ge=0, le=2**32 - 1)]" = (
        betterproto2.field(14, betterproto2.TYPE_UINT32)
    )
    """
    Next ID: 21
    """

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "signalservice", "AttachmentPointer", AttachmentPointer
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class BodyRange(betterproto2.Message):
    """


    Oneofs:
        - associatedValue:
    """

    start: "typing.Annotated[int, pydantic.Field(ge=0, le=2**32 - 1)]" = (
        betterproto2.field(1, betterproto2.TYPE_UINT32)
    )
    """
    Starting index in UTF-16 code units/raw string representation
    """

    length: "typing.Annotated[int, pydantic.Field(ge=0, le=2**32 - 1)]" = (
        betterproto2.field(2, betterproto2.TYPE_UINT32)
    )
    """
    Length of range in UTF-16 code units/raw string representation
    """

    mention_aci: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)] | None" = betterproto2.field(
        3, betterproto2.TYPE_STRING, optional=True, group="associatedValue"
    )

    style: "BodyRangeStyle | None" = betterproto2.field(
        4, betterproto2.TYPE_ENUM, optional=True, group="associatedValue"
    )

    mention_aci_binary: "bytes | None" = betterproto2.field(
        5, betterproto2.TYPE_BYTES, optional=True, group="associatedValue"
    )
    """
    16-byte UUID
    """

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message("signalservice", "BodyRange", BodyRange)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class CallMessage(betterproto2.Message):
    offer: "CallMessageOffer | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )

    answer: "CallMessageAnswer | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )

    ice_update: "list[CallMessageIceUpdate]" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, repeated=True
    )

    busy: "CallMessageBusy | None" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, optional=True
    )

    hangup: "CallMessageHangup | None" = betterproto2.field(
        7, betterproto2.TYPE_MESSAGE, optional=True
    )

    destination_device_id: "typing.Annotated[int, pydantic.Field(ge=0, le=2**32 - 1)]" = betterproto2.field(
        9, betterproto2.TYPE_UINT32
    )

    opaque: "CallMessageOpaque | None" = betterproto2.field(
        10, betterproto2.TYPE_MESSAGE, optional=True
    )


default_message_pool.register_message("signalservice", "CallMessage", CallMessage)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class CallMessageAnswer(betterproto2.Message):
    id: "typing.Annotated[int, pydantic.Field(ge=0, le=2**64 - 1)]" = (
        betterproto2.field(1, betterproto2.TYPE_UINT64)
    )

    opaque: "bytes" = betterproto2.field(3, betterproto2.TYPE_BYTES)


default_message_pool.register_message(
    "signalservice", "CallMessage.Answer", CallMessageAnswer
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class CallMessageBusy(betterproto2.Message):
    id: "typing.Annotated[int, pydantic.Field(ge=0, le=2**64 - 1)]" = (
        betterproto2.field(1, betterproto2.TYPE_UINT64)
    )


default_message_pool.register_message(
    "signalservice", "CallMessage.Busy", CallMessageBusy
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class CallMessageHangup(betterproto2.Message):
    id: "typing.Annotated[int, pydantic.Field(ge=0, le=2**64 - 1)]" = (
        betterproto2.field(1, betterproto2.TYPE_UINT64)
    )

    type: "CallMessageHangupType" = betterproto2.field(
        2, betterproto2.TYPE_ENUM, default_factory=lambda: CallMessageHangupType(0)
    )

    device_id: "typing.Annotated[int, pydantic.Field(ge=0, le=2**32 - 1)]" = (
        betterproto2.field(3, betterproto2.TYPE_UINT32)
    )


default_message_pool.register_message(
    "signalservice", "CallMessage.Hangup", CallMessageHangup
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class CallMessageIceUpdate(betterproto2.Message):
    id: "typing.Annotated[int, pydantic.Field(ge=0, le=2**64 - 1)]" = (
        betterproto2.field(1, betterproto2.TYPE_UINT64)
    )

    opaque: "bytes" = betterproto2.field(5, betterproto2.TYPE_BYTES)


default_message_pool.register_message(
    "signalservice", "CallMessage.IceUpdate", CallMessageIceUpdate
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class CallMessageOffer(betterproto2.Message):
    id: "typing.Annotated[int, pydantic.Field(ge=0, le=2**64 - 1)]" = (
        betterproto2.field(1, betterproto2.TYPE_UINT64)
    )

    type: "CallMessageOfferType" = betterproto2.field(
        3, betterproto2.TYPE_ENUM, default_factory=lambda: CallMessageOfferType(0)
    )

    opaque: "bytes" = betterproto2.field(4, betterproto2.TYPE_BYTES)


default_message_pool.register_message(
    "signalservice", "CallMessage.Offer", CallMessageOffer
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class CallMessageOpaque(betterproto2.Message):
    data: "bytes" = betterproto2.field(1, betterproto2.TYPE_BYTES)

    urgency: "CallMessageOpaqueUrgency" = betterproto2.field(
        2, betterproto2.TYPE_ENUM, default_factory=lambda: CallMessageOpaqueUrgency(0)
    )
    """
    If missing, treat as DROPPABLE.
    """


default_message_pool.register_message(
    "signalservice", "CallMessage.Opaque", CallMessageOpaque
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class ContactDetails(betterproto2.Message):
    number: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )

    aci: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        9, betterproto2.TYPE_STRING
    )

    aci_binary: "bytes" = betterproto2.field(13, betterproto2.TYPE_BYTES)
    """
    16-byte UUID
    """

    name: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        2, betterproto2.TYPE_STRING
    )

    avatar: "ContactDetailsAvatar | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )

    expire_timer: "typing.Annotated[int, pydantic.Field(ge=0, le=2**32 - 1)]" = (
        betterproto2.field(8, betterproto2.TYPE_UINT32)
    )

    expire_timer_version: "typing.Annotated[int, pydantic.Field(ge=0, le=2**32 - 1)]" = betterproto2.field(
        12, betterproto2.TYPE_UINT32
    )

    inbox_position: "typing.Annotated[int, pydantic.Field(ge=0, le=2**32 - 1)]" = (
        betterproto2.field(10, betterproto2.TYPE_UINT32)
    )


default_message_pool.register_message("signalservice", "ContactDetails", ContactDetails)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class ContactDetailsAvatar(betterproto2.Message):
    content_type: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )

    length: "typing.Annotated[int, pydantic.Field(ge=0, le=2**32 - 1)]" = (
        betterproto2.field(2, betterproto2.TYPE_UINT32)
    )


default_message_pool.register_message(
    "signalservice", "ContactDetails.Avatar", ContactDetailsAvatar
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class Content(betterproto2.Message):
    data_message: "DataMessage | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )

    sync_message: "SyncMessage | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )

    call_message: "CallMessage | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )

    null_message: "NullMessage | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True
    )

    receipt_message: "ReceiptMessage | None" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, optional=True
    )

    typing_message: "TypingMessage | None" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, optional=True
    )

    sender_key_distribution_message: "bytes" = betterproto2.field(
        7, betterproto2.TYPE_BYTES
    )

    decryption_error_message: "bytes" = betterproto2.field(8, betterproto2.TYPE_BYTES)

    story_message: "StoryMessage | None" = betterproto2.field(
        9, betterproto2.TYPE_MESSAGE, optional=True
    )

    pni_signature_message: "PniSignatureMessage | None" = betterproto2.field(
        10, betterproto2.TYPE_MESSAGE, optional=True
    )

    edit_message: "EditMessage | None" = betterproto2.field(
        11, betterproto2.TYPE_MESSAGE, optional=True
    )


default_message_pool.register_message("signalservice", "Content", Content)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class ConversationIdentifier(betterproto2.Message):
    """


    Oneofs:
        - identifier:
    """

    thread_service_id: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)] | None" = betterproto2.field(
        1, betterproto2.TYPE_STRING, optional=True, group="identifier"
    )

    thread_group_id: "bytes | None" = betterproto2.field(
        2, betterproto2.TYPE_BYTES, optional=True, group="identifier"
    )

    thread_e_164: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)] | None" = betterproto2.field(
        3, betterproto2.TYPE_STRING, optional=True, group="identifier"
    )

    thread_service_id_binary: "bytes | None" = betterproto2.field(
        4, betterproto2.TYPE_BYTES, optional=True, group="identifier"
    )
    """
    service ID binary (i.e. 16 byte UUID for ACI, 1 byte prefix + 16 byte UUID for PNI)
    """

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "signalservice", "ConversationIdentifier", ConversationIdentifier
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class DataMessage(betterproto2.Message):
    body: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )

    attachments: "list[AttachmentPointer]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )

    group: "GroupContext | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )

    group_v_2: "GroupContextV2 | None" = betterproto2.field(
        15, betterproto2.TYPE_MESSAGE, optional=True
    )

    flags: "typing.Annotated[int, pydantic.Field(ge=0, le=2**32 - 1)]" = (
        betterproto2.field(4, betterproto2.TYPE_UINT32)
    )

    expire_timer: "typing.Annotated[int, pydantic.Field(ge=0, le=2**32 - 1)]" = (
        betterproto2.field(5, betterproto2.TYPE_UINT32)
    )

    expire_timer_version: "typing.Annotated[int, pydantic.Field(ge=0, le=2**32 - 1)]" = betterproto2.field(
        23, betterproto2.TYPE_UINT32
    )

    profile_key: "bytes" = betterproto2.field(6, betterproto2.TYPE_BYTES)

    timestamp: "typing.Annotated[int, pydantic.Field(ge=0, le=2**64 - 1)]" = (
        betterproto2.field(7, betterproto2.TYPE_UINT64)
    )

    quote: "DataMessageQuote | None" = betterproto2.field(
        8, betterproto2.TYPE_MESSAGE, optional=True
    )

    contact: "list[DataMessageContact]" = betterproto2.field(
        9, betterproto2.TYPE_MESSAGE, repeated=True
    )

    preview: "list[Preview]" = betterproto2.field(
        10, betterproto2.TYPE_MESSAGE, repeated=True
    )

    sticker: "DataMessageSticker | None" = betterproto2.field(
        11, betterproto2.TYPE_MESSAGE, optional=True
    )

    required_protocol_version: "typing.Annotated[int, pydantic.Field(ge=0, le=2**32 - 1)]" = betterproto2.field(
        12, betterproto2.TYPE_UINT32
    )

    is_view_once: "bool" = betterproto2.field(14, betterproto2.TYPE_BOOL)

    reaction: "DataMessageReaction | None" = betterproto2.field(
        16, betterproto2.TYPE_MESSAGE, optional=True
    )

    delete: "DataMessageDelete | None" = betterproto2.field(
        17, betterproto2.TYPE_MESSAGE, optional=True
    )

    body_ranges: "list[BodyRange]" = betterproto2.field(
        18, betterproto2.TYPE_MESSAGE, repeated=True
    )

    group_call_update: "DataMessageGroupCallUpdate | None" = betterproto2.field(
        19, betterproto2.TYPE_MESSAGE, optional=True
    )

    payment: "DataMessagePayment | None" = betterproto2.field(
        20, betterproto2.TYPE_MESSAGE, optional=True
    )

    story_context: "DataMessageStoryContext | None" = betterproto2.field(
        21, betterproto2.TYPE_MESSAGE, optional=True
    )

    gift_badge: "DataMessageGiftBadge | None" = betterproto2.field(
        22, betterproto2.TYPE_MESSAGE, optional=True
    )

    poll_create: "DataMessagePollCreate | None" = betterproto2.field(
        24, betterproto2.TYPE_MESSAGE, optional=True
    )

    poll_terminate: "DataMessagePollTerminate | None" = betterproto2.field(
        25, betterproto2.TYPE_MESSAGE, optional=True
    )

    poll_vote: "DataMessagePollVote | None" = betterproto2.field(
        26, betterproto2.TYPE_MESSAGE, optional=True
    )

    pin_message: "DataMessagePinMessage | None" = betterproto2.field(
        27, betterproto2.TYPE_MESSAGE, optional=True
    )

    unpin_message: "DataMessageUnpinMessage | None" = betterproto2.field(
        28, betterproto2.TYPE_MESSAGE, optional=True
    )

    admin_delete: "DataMessageAdminDelete | None" = betterproto2.field(
        29, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    NEXT ID: 30
    """


default_message_pool.register_message("signalservice", "DataMessage", DataMessage)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class DataMessageAdminDelete(betterproto2.Message):
    target_author_aci_binary: "bytes" = betterproto2.field(1, betterproto2.TYPE_BYTES)
    """
    16-byte UUID
    """

    target_sent_timestamp: "typing.Annotated[int, pydantic.Field(ge=0, le=2**64 - 1)]" = betterproto2.field(
        2, betterproto2.TYPE_UINT64
    )


default_message_pool.register_message(
    "signalservice", "DataMessage.AdminDelete", DataMessageAdminDelete
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class DataMessageContact(betterproto2.Message):
    name: "DataMessageContactName | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )

    number: "list[DataMessageContactPhone]" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, repeated=True
    )

    email: "list[DataMessageContactEmail]" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, repeated=True
    )

    address: "list[DataMessageContactPostalAddress]" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, repeated=True
    )

    avatar: "DataMessageContactAvatar | None" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, optional=True
    )

    organization: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        7, betterproto2.TYPE_STRING
    )


default_message_pool.register_message(
    "signalservice", "DataMessage.Contact", DataMessageContact
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class DataMessageContactAvatar(betterproto2.Message):
    avatar: "AttachmentPointer | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )

    is_profile: "bool" = betterproto2.field(2, betterproto2.TYPE_BOOL)


default_message_pool.register_message(
    "signalservice", "DataMessage.Contact.Avatar", DataMessageContactAvatar
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class DataMessageContactEmail(betterproto2.Message):
    value: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )

    type: "DataMessageContactEmailType" = betterproto2.field(
        2,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: DataMessageContactEmailType(0),
    )

    label: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        3, betterproto2.TYPE_STRING
    )


default_message_pool.register_message(
    "signalservice", "DataMessage.Contact.Email", DataMessageContactEmail
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class DataMessageContactName(betterproto2.Message):
    given_name: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )

    family_name: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        2, betterproto2.TYPE_STRING
    )

    prefix: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        3, betterproto2.TYPE_STRING
    )

    suffix: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        4, betterproto2.TYPE_STRING
    )

    middle_name: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        5, betterproto2.TYPE_STRING
    )

    nickname: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        7, betterproto2.TYPE_STRING
    )


default_message_pool.register_message(
    "signalservice", "DataMessage.Contact.Name", DataMessageContactName
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class DataMessageContactPhone(betterproto2.Message):
    value: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )

    type: "DataMessageContactPhoneType" = betterproto2.field(
        2,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: DataMessageContactPhoneType(0),
    )

    label: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        3, betterproto2.TYPE_STRING
    )


default_message_pool.register_message(
    "signalservice", "DataMessage.Contact.Phone", DataMessageContactPhone
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class DataMessageContactPostalAddress(betterproto2.Message):
    type: "DataMessageContactPostalAddressType" = betterproto2.field(
        1,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: DataMessageContactPostalAddressType(0),
    )

    label: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        2, betterproto2.TYPE_STRING
    )

    street: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        3, betterproto2.TYPE_STRING
    )

    pobox: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        4, betterproto2.TYPE_STRING
    )

    neighborhood: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        5, betterproto2.TYPE_STRING
    )

    city: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        6, betterproto2.TYPE_STRING
    )

    region: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        7, betterproto2.TYPE_STRING
    )

    postcode: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        8, betterproto2.TYPE_STRING
    )

    country: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        9, betterproto2.TYPE_STRING
    )


default_message_pool.register_message(
    "signalservice",
    "DataMessage.Contact.PostalAddress",
    DataMessageContactPostalAddress,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class DataMessageDelete(betterproto2.Message):
    target_sent_timestamp: "typing.Annotated[int, pydantic.Field(ge=0, le=2**64 - 1)]" = betterproto2.field(
        1, betterproto2.TYPE_UINT64
    )


default_message_pool.register_message(
    "signalservice", "DataMessage.Delete", DataMessageDelete
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class DataMessageGiftBadge(betterproto2.Message):
    receipt_credential_presentation: "bytes" = betterproto2.field(
        1, betterproto2.TYPE_BYTES
    )


default_message_pool.register_message(
    "signalservice", "DataMessage.GiftBadge", DataMessageGiftBadge
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class DataMessageGroupCallUpdate(betterproto2.Message):
    era_id: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )


default_message_pool.register_message(
    "signalservice", "DataMessage.GroupCallUpdate", DataMessageGroupCallUpdate
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class DataMessagePayment(betterproto2.Message):
    """


    Oneofs:
        - Item:
    """

    notification: "DataMessagePaymentNotification | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True, group="Item"
    )

    activation: "DataMessagePaymentActivation | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True, group="Item"
    )

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "signalservice", "DataMessage.Payment", DataMessagePayment
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class DataMessagePaymentActivation(betterproto2.Message):
    type: "DataMessagePaymentActivationType" = betterproto2.field(
        1,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: DataMessagePaymentActivationType(0),
    )


default_message_pool.register_message(
    "signalservice", "DataMessage.Payment.Activation", DataMessagePaymentActivation
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class DataMessagePaymentAmount(betterproto2.Message):
    """


    Oneofs:
        - Amount:
    """

    mobile_coin: "DataMessagePaymentAmountMobileCoin | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True, group="Amount"
    )

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "signalservice", "DataMessage.Payment.Amount", DataMessagePaymentAmount
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class DataMessagePaymentAmountMobileCoin(betterproto2.Message):
    pico_mob: "typing.Annotated[int, pydantic.Field(ge=0, le=2**64 - 1)]" = (
        betterproto2.field(1, betterproto2.TYPE_UINT64)
    )
    """
    1,000,000,000,000 picoMob per Mob
    """


default_message_pool.register_message(
    "signalservice",
    "DataMessage.Payment.Amount.MobileCoin",
    DataMessagePaymentAmountMobileCoin,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class DataMessagePaymentNotification(betterproto2.Message):
    """


    Oneofs:
        - Transaction:
    """

    mobile_coin: "DataMessagePaymentNotificationMobileCoin | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True, group="Transaction"
    )

    note: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        2, betterproto2.TYPE_STRING
    )
    """
    Optional, Refers to the PaymentRequest message, if any.
    """

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "signalservice", "DataMessage.Payment.Notification", DataMessagePaymentNotification
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class DataMessagePaymentNotificationMobileCoin(betterproto2.Message):
    receipt: "bytes" = betterproto2.field(1, betterproto2.TYPE_BYTES)


default_message_pool.register_message(
    "signalservice",
    "DataMessage.Payment.Notification.MobileCoin",
    DataMessagePaymentNotificationMobileCoin,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class DataMessagePinMessage(betterproto2.Message):
    """


    Oneofs:
        - pinDuration:
    """

    target_author_aci_binary: "bytes" = betterproto2.field(1, betterproto2.TYPE_BYTES)
    """
    16-byte UUID
    """

    target_sent_timestamp: "typing.Annotated[int, pydantic.Field(ge=0, le=2**64 - 1)]" = betterproto2.field(
        2, betterproto2.TYPE_UINT64
    )

    pin_duration_seconds: "typing.Annotated[int, pydantic.Field(ge=0, le=2**32 - 1)] | None" = betterproto2.field(
        3, betterproto2.TYPE_UINT32, optional=True, group="pinDuration"
    )

    pin_duration_forever: "bool | None" = betterproto2.field(
        4, betterproto2.TYPE_BOOL, optional=True, group="pinDuration"
    )

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "signalservice", "DataMessage.PinMessage", DataMessagePinMessage
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class DataMessagePollCreate(betterproto2.Message):
    question: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )

    allow_multiple: "bool" = betterproto2.field(2, betterproto2.TYPE_BOOL)

    options: "list[typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]]" = betterproto2.field(
        3, betterproto2.TYPE_STRING, repeated=True
    )


default_message_pool.register_message(
    "signalservice", "DataMessage.PollCreate", DataMessagePollCreate
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class DataMessagePollTerminate(betterproto2.Message):
    target_sent_timestamp: "typing.Annotated[int, pydantic.Field(ge=0, le=2**64 - 1)]" = betterproto2.field(
        1, betterproto2.TYPE_UINT64
    )


default_message_pool.register_message(
    "signalservice", "DataMessage.PollTerminate", DataMessagePollTerminate
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class DataMessagePollVote(betterproto2.Message):
    target_author_aci_binary: "bytes" = betterproto2.field(1, betterproto2.TYPE_BYTES)

    target_sent_timestamp: "typing.Annotated[int, pydantic.Field(ge=0, le=2**64 - 1)]" = betterproto2.field(
        2, betterproto2.TYPE_UINT64
    )

    option_indexes: "list[typing.Annotated[int, pydantic.Field(ge=0, le=2**32 - 1)]]" = betterproto2.field(
        3, betterproto2.TYPE_UINT32, repeated=True
    )
    """
    must be in the range [0, options.length) from the PollCreate
    """

    vote_count: "typing.Annotated[int, pydantic.Field(ge=0, le=2**32 - 1)]" = (
        betterproto2.field(4, betterproto2.TYPE_UINT32)
    )
    """
    increment this by 1 each time you vote on a given poll
    """


default_message_pool.register_message(
    "signalservice", "DataMessage.PollVote", DataMessagePollVote
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class DataMessageQuote(betterproto2.Message):
    id: "typing.Annotated[int, pydantic.Field(ge=0, le=2**64 - 1)]" = (
        betterproto2.field(1, betterproto2.TYPE_UINT64)
    )

    author_aci: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        5, betterproto2.TYPE_STRING
    )

    text: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        3, betterproto2.TYPE_STRING
    )

    attachments: "list[DataMessageQuoteQuotedAttachment]" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, repeated=True
    )

    body_ranges: "list[BodyRange]" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, repeated=True
    )

    type: "DataMessageQuoteType" = betterproto2.field(
        7, betterproto2.TYPE_ENUM, default_factory=lambda: DataMessageQuoteType(0)
    )

    author_aci_binary: "bytes" = betterproto2.field(8, betterproto2.TYPE_BYTES)
    """
    16-byte UUID
    """


default_message_pool.register_message(
    "signalservice", "DataMessage.Quote", DataMessageQuote
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class DataMessageQuoteQuotedAttachment(betterproto2.Message):
    content_type: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )

    file_name: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        2, betterproto2.TYPE_STRING
    )

    thumbnail: "AttachmentPointer | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )


default_message_pool.register_message(
    "signalservice",
    "DataMessage.Quote.QuotedAttachment",
    DataMessageQuoteQuotedAttachment,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class DataMessageReaction(betterproto2.Message):
    emoji: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )

    remove: "bool" = betterproto2.field(2, betterproto2.TYPE_BOOL)

    target_author_aci: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        4, betterproto2.TYPE_STRING
    )

    target_sent_timestamp: "typing.Annotated[int, pydantic.Field(ge=0, le=2**64 - 1)]" = betterproto2.field(
        5, betterproto2.TYPE_UINT64
    )

    target_author_aci_binary: "bytes" = betterproto2.field(6, betterproto2.TYPE_BYTES)
    """
    16-byte UUID
    """


default_message_pool.register_message(
    "signalservice", "DataMessage.Reaction", DataMessageReaction
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class DataMessageSticker(betterproto2.Message):
    pack_id: "bytes" = betterproto2.field(1, betterproto2.TYPE_BYTES)

    pack_key: "bytes" = betterproto2.field(2, betterproto2.TYPE_BYTES)

    sticker_id: "typing.Annotated[int, pydantic.Field(ge=0, le=2**32 - 1)]" = (
        betterproto2.field(3, betterproto2.TYPE_UINT32)
    )

    data: "AttachmentPointer | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True
    )

    emoji: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        5, betterproto2.TYPE_STRING
    )


default_message_pool.register_message(
    "signalservice", "DataMessage.Sticker", DataMessageSticker
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class DataMessageStoryContext(betterproto2.Message):
    author_aci: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )

    sent_timestamp: "typing.Annotated[int, pydantic.Field(ge=0, le=2**64 - 1)]" = (
        betterproto2.field(2, betterproto2.TYPE_UINT64)
    )

    author_aci_binary: "bytes" = betterproto2.field(3, betterproto2.TYPE_BYTES)
    """
    16-byte UUID
    """


default_message_pool.register_message(
    "signalservice", "DataMessage.StoryContext", DataMessageStoryContext
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class DataMessageUnpinMessage(betterproto2.Message):
    target_author_aci_binary: "bytes" = betterproto2.field(1, betterproto2.TYPE_BYTES)
    """
    16-byte UUID
    """

    target_sent_timestamp: "typing.Annotated[int, pydantic.Field(ge=0, le=2**64 - 1)]" = betterproto2.field(
        2, betterproto2.TYPE_UINT64
    )


default_message_pool.register_message(
    "signalservice", "DataMessage.UnpinMessage", DataMessageUnpinMessage
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class DecryptionErrorMessage(betterproto2.Message):
    ratchet_key: "bytes" = betterproto2.field(1, betterproto2.TYPE_BYTES)
    """
    set to the public ratchet key from the SignalMessage if a 1-1 payload fails to decrypt
    """

    timestamp: "typing.Annotated[int, pydantic.Field(ge=0, le=2**64 - 1)]" = (
        betterproto2.field(2, betterproto2.TYPE_UINT64)
    )

    device_id: "typing.Annotated[int, pydantic.Field(ge=0, le=2**32 - 1)]" = (
        betterproto2.field(3, betterproto2.TYPE_UINT32)
    )


default_message_pool.register_message(
    "signalservice", "DecryptionErrorMessage", DecryptionErrorMessage
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class EditMessage(betterproto2.Message):
    target_sent_timestamp: "typing.Annotated[int, pydantic.Field(ge=0, le=2**64 - 1)]" = betterproto2.field(
        1, betterproto2.TYPE_UINT64
    )

    data_message: "DataMessage | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )


default_message_pool.register_message("signalservice", "EditMessage", EditMessage)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class Envelope(betterproto2.Message):
    type: "EnvelopeType" = betterproto2.field(
        1, betterproto2.TYPE_ENUM, default_factory=lambda: EnvelopeType(0)
    )

    source_service_id: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        11, betterproto2.TYPE_STRING
    )

    source_device: "typing.Annotated[int, pydantic.Field(ge=0, le=2**32 - 1)]" = (
        betterproto2.field(7, betterproto2.TYPE_UINT32)
    )

    destination_service_id: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        13, betterproto2.TYPE_STRING
    )

    timestamp: "typing.Annotated[int, pydantic.Field(ge=0, le=2**64 - 1)]" = (
        betterproto2.field(5, betterproto2.TYPE_UINT64)
    )

    content: "bytes" = betterproto2.field(8, betterproto2.TYPE_BYTES)
    """
    Contains an encrypted Content
    """

    server_guid: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        9, betterproto2.TYPE_STRING
    )

    server_timestamp: "typing.Annotated[int, pydantic.Field(ge=0, le=2**64 - 1)]" = (
        betterproto2.field(10, betterproto2.TYPE_UINT64)
    )

    ephemeral: "bool" = betterproto2.field(12, betterproto2.TYPE_BOOL)
    """
    indicates that the message should not be persisted if the recipient is offline
    """

    urgent: "bool" = betterproto2.field(14, betterproto2.TYPE_BOOL)
    """
    indicates that the content is considered timely by the sender; defaults to true so senders have to opt-out to say something isn't time critical
    """

    updated_pni: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        15, betterproto2.TYPE_STRING
    )
    """
    for number-change synchronization messages, provides the new server-assigned phone number identifier associated with the changed number
    """

    story: "bool" = betterproto2.field(16, betterproto2.TYPE_BOOL)
    """
    indicates that the content is a story.
    """

    report_spam_token: "bytes" = betterproto2.field(17, betterproto2.TYPE_BYTES)
    """
    token sent when reporting spam
    """

    source_service_id_binary: "bytes" = betterproto2.field(19, betterproto2.TYPE_BYTES)
    """
    service ID binary (i.e. 16 byte UUID for ACI, 1 byte prefix + 16 byte UUID for PNI)
    """

    destination_service_id_binary: "bytes" = betterproto2.field(
        20, betterproto2.TYPE_BYTES
    )
    """
    service ID binary (i.e. 16 byte UUID for ACI, 1 byte prefix + 16 byte UUID for PNI)
    """

    server_guid_binary: "bytes" = betterproto2.field(21, betterproto2.TYPE_BYTES)
    """
    16-byte UUID
    """

    updated_pni_binary: "bytes" = betterproto2.field(22, betterproto2.TYPE_BYTES)
    """
    16-byte UUID
    """


default_message_pool.register_message("signalservice", "Envelope", Envelope)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class GroupContext(betterproto2.Message):
    id: "bytes" = betterproto2.field(1, betterproto2.TYPE_BYTES)

    type: "GroupContextType" = betterproto2.field(
        2, betterproto2.TYPE_ENUM, default_factory=lambda: GroupContextType(0)
    )

    name: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        3, betterproto2.TYPE_STRING
    )

    members_e_164: "list[typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]]" = betterproto2.field(
        4, betterproto2.TYPE_STRING, repeated=True
    )

    members: "list[GroupContextMember]" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, repeated=True
    )

    avatar: "AttachmentPointer | None" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, optional=True
    )


default_message_pool.register_message("signalservice", "GroupContext", GroupContext)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class GroupContextMember(betterproto2.Message):
    e164: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        2, betterproto2.TYPE_STRING
    )


default_message_pool.register_message(
    "signalservice", "GroupContext.Member", GroupContextMember
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class GroupContextV2(betterproto2.Message):
    master_key: "bytes" = betterproto2.field(1, betterproto2.TYPE_BYTES)

    revision: "typing.Annotated[int, pydantic.Field(ge=0, le=2**32 - 1)]" = (
        betterproto2.field(2, betterproto2.TYPE_UINT32)
    )

    group_change: "bytes" = betterproto2.field(3, betterproto2.TYPE_BYTES)


default_message_pool.register_message("signalservice", "GroupContextV2", GroupContextV2)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class NullMessage(betterproto2.Message):
    padding: "bytes" = betterproto2.field(1, betterproto2.TYPE_BYTES)


default_message_pool.register_message("signalservice", "NullMessage", NullMessage)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class PaymentAddress(betterproto2.Message):
    """


    Oneofs:
        - Address:
    """

    mobile_coin: "PaymentAddressMobileCoin | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True, group="Address"
    )

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message("signalservice", "PaymentAddress", PaymentAddress)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class PaymentAddressMobileCoin(betterproto2.Message):
    public_address: "bytes" = betterproto2.field(1, betterproto2.TYPE_BYTES)

    signature: "bytes" = betterproto2.field(2, betterproto2.TYPE_BYTES)


default_message_pool.register_message(
    "signalservice", "PaymentAddress.MobileCoin", PaymentAddressMobileCoin
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class PniSignatureMessage(betterproto2.Message):
    pni: "bytes" = betterproto2.field(1, betterproto2.TYPE_BYTES)

    signature: "bytes" = betterproto2.field(2, betterproto2.TYPE_BYTES)
    """
    Signature *by* the PNI identity key *of* the ACI identity key
    """


default_message_pool.register_message(
    "signalservice", "PniSignatureMessage", PniSignatureMessage
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class Preview(betterproto2.Message):
    url: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )

    title: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        2, betterproto2.TYPE_STRING
    )

    image: "AttachmentPointer | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )

    description: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        4, betterproto2.TYPE_STRING
    )

    date: "typing.Annotated[int, pydantic.Field(ge=0, le=2**64 - 1)]" = (
        betterproto2.field(5, betterproto2.TYPE_UINT64)
    )


default_message_pool.register_message("signalservice", "Preview", Preview)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class ReceiptMessage(betterproto2.Message):
    type: "ReceiptMessageType" = betterproto2.field(
        1, betterproto2.TYPE_ENUM, default_factory=lambda: ReceiptMessageType(0)
    )

    timestamp: "list[typing.Annotated[int, pydantic.Field(ge=0, le=2**64 - 1)]]" = (
        betterproto2.field(2, betterproto2.TYPE_UINT64, repeated=True)
    )


default_message_pool.register_message("signalservice", "ReceiptMessage", ReceiptMessage)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class StoryMessage(betterproto2.Message):
    """


    Oneofs:
        - attachment:
    """

    profile_key: "bytes" = betterproto2.field(1, betterproto2.TYPE_BYTES)

    group: "GroupContextV2 | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )

    file_attachment: "AttachmentPointer | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True, group="attachment"
    )

    text_attachment: "TextAttachment | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True, group="attachment"
    )

    allows_replies: "bool" = betterproto2.field(5, betterproto2.TYPE_BOOL)

    body_ranges: "list[BodyRange]" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, repeated=True
    )

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message("signalservice", "StoryMessage", StoryMessage)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class SyncMessage(betterproto2.Message):
    sent: "SyncMessageSent | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )

    contacts: "SyncMessageContacts | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )

    groups: "SyncMessageGroups | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )

    request: "SyncMessageRequest | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True
    )

    read: "list[SyncMessageRead]" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, repeated=True
    )

    blocked: "SyncMessageBlocked | None" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, optional=True
    )

    verified: "Verified | None" = betterproto2.field(
        7, betterproto2.TYPE_MESSAGE, optional=True
    )

    configuration: "SyncMessageConfiguration | None" = betterproto2.field(
        9, betterproto2.TYPE_MESSAGE, optional=True
    )

    padding: "bytes" = betterproto2.field(8, betterproto2.TYPE_BYTES)

    sticker_pack_operation: "list[SyncMessageStickerPackOperation]" = (
        betterproto2.field(10, betterproto2.TYPE_MESSAGE, repeated=True)
    )

    view_once_open: "SyncMessageViewOnceOpen | None" = betterproto2.field(
        11, betterproto2.TYPE_MESSAGE, optional=True
    )

    fetch_latest: "SyncMessageFetchLatest | None" = betterproto2.field(
        12, betterproto2.TYPE_MESSAGE, optional=True
    )

    keys: "SyncMessageKeys | None" = betterproto2.field(
        13, betterproto2.TYPE_MESSAGE, optional=True
    )

    message_request_response: "SyncMessageMessageRequestResponse | None" = (
        betterproto2.field(14, betterproto2.TYPE_MESSAGE, optional=True)
    )

    outgoing_payment: "SyncMessageOutgoingPayment | None" = betterproto2.field(
        15, betterproto2.TYPE_MESSAGE, optional=True
    )

    viewed: "list[SyncMessageViewed]" = betterproto2.field(
        16, betterproto2.TYPE_MESSAGE, repeated=True
    )

    pni_change_number: "SyncMessagePniChangeNumber | None" = betterproto2.field(
        18, betterproto2.TYPE_MESSAGE, optional=True
    )

    call_event: "SyncMessageCallEvent | None" = betterproto2.field(
        19, betterproto2.TYPE_MESSAGE, optional=True
    )

    call_link_update: "SyncMessageCallLinkUpdate | None" = betterproto2.field(
        20, betterproto2.TYPE_MESSAGE, optional=True
    )

    call_log_event: "SyncMessageCallLogEvent | None" = betterproto2.field(
        21, betterproto2.TYPE_MESSAGE, optional=True
    )

    delete_for_me: "SyncMessageDeleteForMe | None" = betterproto2.field(
        22, betterproto2.TYPE_MESSAGE, optional=True
    )

    device_name_change: "SyncMessageDeviceNameChange | None" = betterproto2.field(
        23, betterproto2.TYPE_MESSAGE, optional=True
    )

    attachment_backfill_request: "SyncMessageAttachmentBackfillRequest | None" = (
        betterproto2.field(24, betterproto2.TYPE_MESSAGE, optional=True)
    )

    attachment_backfill_response: "SyncMessageAttachmentBackfillResponse | None" = (
        betterproto2.field(25, betterproto2.TYPE_MESSAGE, optional=True)
    )


default_message_pool.register_message("signalservice", "SyncMessage", SyncMessage)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class SyncMessageAttachmentBackfillRequest(betterproto2.Message):
    target_message: "AddressableMessage | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )

    target_conversation: "ConversationIdentifier | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )


default_message_pool.register_message(
    "signalservice",
    "SyncMessage.AttachmentBackfillRequest",
    SyncMessageAttachmentBackfillRequest,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class SyncMessageAttachmentBackfillResponse(betterproto2.Message):
    """


    Oneofs:
        - data:
    """

    target_message: "AddressableMessage | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )

    target_conversation: "ConversationIdentifier | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )

    attachments: "SyncMessageAttachmentBackfillResponseAttachmentDataList | None" = (
        betterproto2.field(3, betterproto2.TYPE_MESSAGE, optional=True, group="data")
    )

    error: "SyncMessageAttachmentBackfillResponseError | None" = betterproto2.field(
        4, betterproto2.TYPE_ENUM, optional=True, group="data"
    )

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "signalservice",
    "SyncMessage.AttachmentBackfillResponse",
    SyncMessageAttachmentBackfillResponse,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class SyncMessageAttachmentBackfillResponseAttachmentData(betterproto2.Message):
    """


    Oneofs:
        - data:
    """

    attachment: "AttachmentPointer | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True, group="data"
    )

    status: "SyncMessageAttachmentBackfillResponseAttachmentDataStatus | None" = (
        betterproto2.field(2, betterproto2.TYPE_ENUM, optional=True, group="data")
    )

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "signalservice",
    "SyncMessage.AttachmentBackfillResponse.AttachmentData",
    SyncMessageAttachmentBackfillResponseAttachmentData,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class SyncMessageAttachmentBackfillResponseAttachmentDataList(betterproto2.Message):
    attachments: "list[SyncMessageAttachmentBackfillResponseAttachmentData]" = (
        betterproto2.field(1, betterproto2.TYPE_MESSAGE, repeated=True)
    )

    long_text: "SyncMessageAttachmentBackfillResponseAttachmentData | None" = (
        betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)
    )


default_message_pool.register_message(
    "signalservice",
    "SyncMessage.AttachmentBackfillResponse.AttachmentDataList",
    SyncMessageAttachmentBackfillResponseAttachmentDataList,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class SyncMessageBlocked(betterproto2.Message):
    numbers: "list[typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]]" = betterproto2.field(
        1, betterproto2.TYPE_STRING, repeated=True
    )

    acis: "list[typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]]" = betterproto2.field(
        3, betterproto2.TYPE_STRING, repeated=True
    )

    group_ids: "list[bytes]" = betterproto2.field(
        2, betterproto2.TYPE_BYTES, repeated=True
    )

    acis_binary: "list[bytes]" = betterproto2.field(
        4, betterproto2.TYPE_BYTES, repeated=True
    )
    """
    16-byte UUID
    """


default_message_pool.register_message(
    "signalservice", "SyncMessage.Blocked", SyncMessageBlocked
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class SyncMessageCallEvent(betterproto2.Message):
    conversation_id: "bytes" = betterproto2.field(1, betterproto2.TYPE_BYTES)
    """
    Data identifying a conversation. The service ID for 1:1, the group ID for
    group, or the room ID for an ad-hoc call. See also
    `CallLogEvent/conversationId`.
    """

    call_id: "typing.Annotated[int, pydantic.Field(ge=0, le=2**64 - 1)]" = (
        betterproto2.field(2, betterproto2.TYPE_UINT64)
    )
    """
    An identifier for a call. Generated directly for 1:1, or derived from
    the era ID for group and ad-hoc calls. See also `CallLogEvent/callId`.
    """

    timestamp: "typing.Annotated[int, pydantic.Field(ge=0, le=2**64 - 1)]" = (
        betterproto2.field(3, betterproto2.TYPE_UINT64)
    )

    type: "SyncMessageCallEventType" = betterproto2.field(
        4, betterproto2.TYPE_ENUM, default_factory=lambda: SyncMessageCallEventType(0)
    )

    direction: "SyncMessageCallEventDirection" = betterproto2.field(
        5,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: SyncMessageCallEventDirection(0),
    )

    event: "SyncMessageCallEventEvent" = betterproto2.field(
        6, betterproto2.TYPE_ENUM, default_factory=lambda: SyncMessageCallEventEvent(0)
    )


default_message_pool.register_message(
    "signalservice", "SyncMessage.CallEvent", SyncMessageCallEvent
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class SyncMessageCallLinkUpdate(betterproto2.Message):
    root_key: "bytes" = betterproto2.field(1, betterproto2.TYPE_BYTES)

    admin_passkey: "bytes" = betterproto2.field(2, betterproto2.TYPE_BYTES)

    type: "SyncMessageCallLinkUpdateType" = betterproto2.field(
        3,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: SyncMessageCallLinkUpdateType(0),
    )
    """
    defaults to UPDATE
    """


default_message_pool.register_message(
    "signalservice", "SyncMessage.CallLinkUpdate", SyncMessageCallLinkUpdate
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class SyncMessageCallLogEvent(betterproto2.Message):
    type: "SyncMessageCallLogEventType" = betterproto2.field(
        1,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: SyncMessageCallLogEventType(0),
    )

    timestamp: "typing.Annotated[int, pydantic.Field(ge=0, le=2**64 - 1)]" = (
        betterproto2.field(2, betterproto2.TYPE_UINT64)
    )

    conversation_id: "bytes" = betterproto2.field(3, betterproto2.TYPE_BYTES)
    """
    Data identifying a conversation. The service ID for 1:1, the group ID for
    group, or the room ID for an ad-hoc call. See also
    `CallEvent/conversationId`.
    """

    call_id: "typing.Annotated[int, pydantic.Field(ge=0, le=2**64 - 1)]" = (
        betterproto2.field(4, betterproto2.TYPE_UINT64)
    )
    """
    An identifier for a call. Generated directly for 1:1, or derived from
    the era ID for group and ad-hoc calls. See also `CallEvent/callId`.
    """


default_message_pool.register_message(
    "signalservice", "SyncMessage.CallLogEvent", SyncMessageCallLogEvent
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class SyncMessageConfiguration(betterproto2.Message):
    read_receipts: "bool" = betterproto2.field(1, betterproto2.TYPE_BOOL)

    unidentified_delivery_indicators: "bool" = betterproto2.field(
        2, betterproto2.TYPE_BOOL
    )

    typing_indicators: "bool" = betterproto2.field(3, betterproto2.TYPE_BOOL)

    provisioning_version: "typing.Annotated[int, pydantic.Field(ge=0, le=2**32 - 1)]" = betterproto2.field(
        5, betterproto2.TYPE_UINT32
    )

    link_previews: "bool" = betterproto2.field(6, betterproto2.TYPE_BOOL)


default_message_pool.register_message(
    "signalservice", "SyncMessage.Configuration", SyncMessageConfiguration
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class SyncMessageContacts(betterproto2.Message):
    blob: "AttachmentPointer | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )

    complete: "bool" = betterproto2.field(2, betterproto2.TYPE_BOOL)


default_message_pool.register_message(
    "signalservice", "SyncMessage.Contacts", SyncMessageContacts
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class SyncMessageDeleteForMe(betterproto2.Message):
    message_deletes: "list[SyncMessageDeleteForMeMessageDeletes]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )

    conversation_deletes: "list[SyncMessageDeleteForMeConversationDelete]" = (
        betterproto2.field(2, betterproto2.TYPE_MESSAGE, repeated=True)
    )

    local_only_conversation_deletes: "list[SyncMessageDeleteForMeLocalOnlyConversationDelete]" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, repeated=True
    )

    attachment_deletes: "list[SyncMessageDeleteForMeAttachmentDelete]" = (
        betterproto2.field(4, betterproto2.TYPE_MESSAGE, repeated=True)
    )


default_message_pool.register_message(
    "signalservice", "SyncMessage.DeleteForMe", SyncMessageDeleteForMe
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class SyncMessageDeleteForMeAttachmentDelete(betterproto2.Message):
    conversation: "ConversationIdentifier | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )

    target_message: "AddressableMessage | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )

    client_uuid: "bytes" = betterproto2.field(3, betterproto2.TYPE_BYTES)
    """
    The `clientUuid` from `AttachmentPointer`.
    """

    fallback_digest: "bytes" = betterproto2.field(4, betterproto2.TYPE_BYTES)
    """
    SHA256 hash of the (encrypted, padded, etc.) attachment blob on the CDN.
    """

    fallback_plaintext_hash: "bytes" = betterproto2.field(5, betterproto2.TYPE_BYTES)
    """
    SHA256 hash of the plaintext content of the attachment.
    """


default_message_pool.register_message(
    "signalservice",
    "SyncMessage.DeleteForMe.AttachmentDelete",
    SyncMessageDeleteForMeAttachmentDelete,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class SyncMessageDeleteForMeConversationDelete(betterproto2.Message):
    conversation: "ConversationIdentifier | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )

    most_recent_messages: "list[AddressableMessage]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )

    is_full_delete: "bool" = betterproto2.field(3, betterproto2.TYPE_BOOL)

    most_recent_non_expiring_messages: "list[AddressableMessage]" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, repeated=True
    )


default_message_pool.register_message(
    "signalservice",
    "SyncMessage.DeleteForMe.ConversationDelete",
    SyncMessageDeleteForMeConversationDelete,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class SyncMessageDeleteForMeLocalOnlyConversationDelete(betterproto2.Message):
    conversation: "ConversationIdentifier | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )


default_message_pool.register_message(
    "signalservice",
    "SyncMessage.DeleteForMe.LocalOnlyConversationDelete",
    SyncMessageDeleteForMeLocalOnlyConversationDelete,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class SyncMessageDeleteForMeMessageDeletes(betterproto2.Message):
    conversation: "ConversationIdentifier | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )

    messages: "list[AddressableMessage]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )


default_message_pool.register_message(
    "signalservice",
    "SyncMessage.DeleteForMe.MessageDeletes",
    SyncMessageDeleteForMeMessageDeletes,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class SyncMessageDeviceNameChange(betterproto2.Message):
    device_id: "typing.Annotated[int, pydantic.Field(ge=0, le=2**32 - 1)]" = (
        betterproto2.field(2, betterproto2.TYPE_UINT32)
    )


default_message_pool.register_message(
    "signalservice", "SyncMessage.DeviceNameChange", SyncMessageDeviceNameChange
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class SyncMessageFetchLatest(betterproto2.Message):
    type: "SyncMessageFetchLatestType" = betterproto2.field(
        1, betterproto2.TYPE_ENUM, default_factory=lambda: SyncMessageFetchLatestType(0)
    )


default_message_pool.register_message(
    "signalservice", "SyncMessage.FetchLatest", SyncMessageFetchLatest
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class SyncMessageGroups(betterproto2.Message):
    blob: "AttachmentPointer | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )


default_message_pool.register_message(
    "signalservice", "SyncMessage.Groups", SyncMessageGroups
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class SyncMessageKeys(betterproto2.Message):
    master: "bytes" = betterproto2.field(2, betterproto2.TYPE_BYTES)
    """
    deprecated: this field will be removed in a future release.
    """

    account_entropy_pool: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        3, betterproto2.TYPE_STRING
    )

    media_root_backup_key: "bytes" = betterproto2.field(4, betterproto2.TYPE_BYTES)


default_message_pool.register_message(
    "signalservice", "SyncMessage.Keys", SyncMessageKeys
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class SyncMessageMessageRequestResponse(betterproto2.Message):
    thread_aci: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        2, betterproto2.TYPE_STRING
    )

    group_id: "bytes" = betterproto2.field(3, betterproto2.TYPE_BYTES)

    type: "SyncMessageMessageRequestResponseType" = betterproto2.field(
        4,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: SyncMessageMessageRequestResponseType(0),
    )

    thread_aci_binary: "bytes" = betterproto2.field(5, betterproto2.TYPE_BYTES)
    """
    16-byte UUID
    """


default_message_pool.register_message(
    "signalservice",
    "SyncMessage.MessageRequestResponse",
    SyncMessageMessageRequestResponse,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class SyncMessageOutgoingPayment(betterproto2.Message):
    """


    Oneofs:
        - attachment_identifier:
    """

    recipient_service_id: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )

    note: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        2, betterproto2.TYPE_STRING
    )

    mobile_coin: "SyncMessageOutgoingPaymentMobileCoin | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True, group="attachment_identifier"
    )

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message(
    "signalservice", "SyncMessage.OutgoingPayment", SyncMessageOutgoingPayment
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class SyncMessageOutgoingPaymentMobileCoin(betterproto2.Message):
    recipient_address: "bytes" = betterproto2.field(1, betterproto2.TYPE_BYTES)

    amount_pico_mob: "typing.Annotated[int, pydantic.Field(ge=0, le=2**64 - 1)]" = (
        betterproto2.field(2, betterproto2.TYPE_UINT64)
    )

    fee_pico_mob: "typing.Annotated[int, pydantic.Field(ge=0, le=2**64 - 1)]" = (
        betterproto2.field(3, betterproto2.TYPE_UINT64)
    )

    receipt: "bytes" = betterproto2.field(4, betterproto2.TYPE_BYTES)

    ledger_block_timestamp: "typing.Annotated[int, pydantic.Field(ge=0, le=2**64 - 1)]" = betterproto2.field(
        5, betterproto2.TYPE_UINT64
    )

    ledger_block_index: "typing.Annotated[int, pydantic.Field(ge=0, le=2**64 - 1)]" = (
        betterproto2.field(6, betterproto2.TYPE_UINT64)
    )

    spent_key_images: "list[bytes]" = betterproto2.field(
        7, betterproto2.TYPE_BYTES, repeated=True
    )

    output_public_keys: "list[bytes]" = betterproto2.field(
        8, betterproto2.TYPE_BYTES, repeated=True
    )


default_message_pool.register_message(
    "signalservice",
    "SyncMessage.OutgoingPayment.MobileCoin",
    SyncMessageOutgoingPaymentMobileCoin,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class SyncMessagePniChangeNumber(betterproto2.Message):
    identity_key_pair: "bytes" = betterproto2.field(1, betterproto2.TYPE_BYTES)
    """
    Serialized libsignal-client IdentityKeyPair
    """

    signed_pre_key: "bytes" = betterproto2.field(2, betterproto2.TYPE_BYTES)
    """
    Serialized libsignal-client SignedPreKeyRecord
    """

    last_resort_kyber_pre_key: "bytes" = betterproto2.field(5, betterproto2.TYPE_BYTES)
    """
    Serialized libsignal-client KyberPreKeyRecord
    """

    registration_id: "typing.Annotated[int, pydantic.Field(ge=0, le=2**32 - 1)]" = (
        betterproto2.field(3, betterproto2.TYPE_UINT32)
    )

    new_e_164: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        4, betterproto2.TYPE_STRING
    )
    """
    The e164 we have changed our number to
    """


default_message_pool.register_message(
    "signalservice", "SyncMessage.PniChangeNumber", SyncMessagePniChangeNumber
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class SyncMessagePniIdentity(betterproto2.Message):
    public_key: "bytes" = betterproto2.field(1, betterproto2.TYPE_BYTES)

    private_key: "bytes" = betterproto2.field(2, betterproto2.TYPE_BYTES)


default_message_pool.register_message(
    "signalservice", "SyncMessage.PniIdentity", SyncMessagePniIdentity
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class SyncMessageRead(betterproto2.Message):
    sender_aci: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        3, betterproto2.TYPE_STRING
    )

    timestamp: "typing.Annotated[int, pydantic.Field(ge=0, le=2**64 - 1)]" = (
        betterproto2.field(2, betterproto2.TYPE_UINT64)
    )

    sender_aci_binary: "bytes" = betterproto2.field(4, betterproto2.TYPE_BYTES)
    """
    16-byte UUID
    """


default_message_pool.register_message(
    "signalservice", "SyncMessage.Read", SyncMessageRead
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class SyncMessageRequest(betterproto2.Message):
    type: "SyncMessageRequestType" = betterproto2.field(
        1, betterproto2.TYPE_ENUM, default_factory=lambda: SyncMessageRequestType(0)
    )


default_message_pool.register_message(
    "signalservice", "SyncMessage.Request", SyncMessageRequest
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class SyncMessageSent(betterproto2.Message):
    destination_e_164: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )

    destination_service_id: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        7, betterproto2.TYPE_STRING
    )

    timestamp: "typing.Annotated[int, pydantic.Field(ge=0, le=2**64 - 1)]" = (
        betterproto2.field(2, betterproto2.TYPE_UINT64)
    )

    message: "DataMessage | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )

    expiration_start_timestamp: "typing.Annotated[int, pydantic.Field(ge=0, le=2**64 - 1)]" = betterproto2.field(
        4, betterproto2.TYPE_UINT64
    )

    unidentified_status: "list[SyncMessageSentUnidentifiedDeliveryStatus]" = (
        betterproto2.field(5, betterproto2.TYPE_MESSAGE, repeated=True)
    )

    is_recipient_update: "bool" = betterproto2.field(6, betterproto2.TYPE_BOOL)

    story_message: "StoryMessage | None" = betterproto2.field(
        8, betterproto2.TYPE_MESSAGE, optional=True
    )

    story_message_recipients: "list[SyncMessageSentStoryMessageRecipient]" = (
        betterproto2.field(9, betterproto2.TYPE_MESSAGE, repeated=True)
    )

    edit_message: "EditMessage | None" = betterproto2.field(
        10, betterproto2.TYPE_MESSAGE, optional=True
    )

    destination_service_id_binary: "bytes" = betterproto2.field(
        12, betterproto2.TYPE_BYTES
    )
    """
    service ID binary (i.e. 16 byte UUID for ACI, 1 byte prefix + 16 byte UUID for PNI)
    """


default_message_pool.register_message(
    "signalservice", "SyncMessage.Sent", SyncMessageSent
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class SyncMessageSentStoryMessageRecipient(betterproto2.Message):
    destination_service_id: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )

    distribution_list_ids: "list[typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]]" = betterproto2.field(
        2, betterproto2.TYPE_STRING, repeated=True
    )

    is_allowed_to_reply: "bool" = betterproto2.field(3, betterproto2.TYPE_BOOL)

    destination_service_id_binary: "bytes" = betterproto2.field(
        5, betterproto2.TYPE_BYTES
    )
    """
    service ID binary (i.e. 16 byte UUID for ACI, 1 byte prefix + 16 byte UUID for PNI)
    """


default_message_pool.register_message(
    "signalservice",
    "SyncMessage.Sent.StoryMessageRecipient",
    SyncMessageSentStoryMessageRecipient,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class SyncMessageSentUnidentifiedDeliveryStatus(betterproto2.Message):
    destination_service_id: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        3, betterproto2.TYPE_STRING
    )

    unidentified: "bool" = betterproto2.field(2, betterproto2.TYPE_BOOL)

    destination_pni_identity_key: "bytes" = betterproto2.field(
        5, betterproto2.TYPE_BYTES
    )
    """
    Only set for PNI destinations
    """

    destination_service_id_binary: "bytes" = betterproto2.field(
        6, betterproto2.TYPE_BYTES
    )
    """
    service ID binary (i.e. 16 byte UUID for ACI, 1 byte prefix + 16 byte UUID for PNI)
    """


default_message_pool.register_message(
    "signalservice",
    "SyncMessage.Sent.UnidentifiedDeliveryStatus",
    SyncMessageSentUnidentifiedDeliveryStatus,
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class SyncMessageStickerPackOperation(betterproto2.Message):
    pack_id: "bytes" = betterproto2.field(1, betterproto2.TYPE_BYTES)

    pack_key: "bytes" = betterproto2.field(2, betterproto2.TYPE_BYTES)

    type: "SyncMessageStickerPackOperationType" = betterproto2.field(
        3,
        betterproto2.TYPE_ENUM,
        default_factory=lambda: SyncMessageStickerPackOperationType(0),
    )


default_message_pool.register_message(
    "signalservice", "SyncMessage.StickerPackOperation", SyncMessageStickerPackOperation
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class SyncMessageViewed(betterproto2.Message):
    sender_aci: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        3, betterproto2.TYPE_STRING
    )

    timestamp: "typing.Annotated[int, pydantic.Field(ge=0, le=2**64 - 1)]" = (
        betterproto2.field(2, betterproto2.TYPE_UINT64)
    )

    sender_aci_binary: "bytes" = betterproto2.field(4, betterproto2.TYPE_BYTES)
    """
    16-byte UUID
    """


default_message_pool.register_message(
    "signalservice", "SyncMessage.Viewed", SyncMessageViewed
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class SyncMessageViewOnceOpen(betterproto2.Message):
    sender_aci: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        3, betterproto2.TYPE_STRING
    )

    timestamp: "typing.Annotated[int, pydantic.Field(ge=0, le=2**64 - 1)]" = (
        betterproto2.field(2, betterproto2.TYPE_UINT64)
    )

    sender_aci_binary: "bytes" = betterproto2.field(4, betterproto2.TYPE_BYTES)
    """
    16-byte UUID
    """


default_message_pool.register_message(
    "signalservice", "SyncMessage.ViewOnceOpen", SyncMessageViewOnceOpen
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class TextAttachment(betterproto2.Message):
    """


    Oneofs:
        - background:
    """

    text: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        1, betterproto2.TYPE_STRING
    )

    text_style: "TextAttachmentStyle" = betterproto2.field(
        2, betterproto2.TYPE_ENUM, default_factory=lambda: TextAttachmentStyle(0)
    )

    text_foreground_color: "typing.Annotated[int, pydantic.Field(ge=0, le=2**32 - 1)]" = betterproto2.field(
        3, betterproto2.TYPE_UINT32
    )
    """
    integer representation of hex color
    """

    text_background_color: "typing.Annotated[int, pydantic.Field(ge=0, le=2**32 - 1)]" = betterproto2.field(
        4, betterproto2.TYPE_UINT32
    )

    preview: "Preview | None" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, optional=True
    )

    gradient: "TextAttachmentGradient | None" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, optional=True, group="background"
    )

    color: "typing.Annotated[int, pydantic.Field(ge=0, le=2**32 - 1)] | None" = (
        betterproto2.field(
            7, betterproto2.TYPE_UINT32, optional=True, group="background"
        )
    )

    @model_validator(mode="after")
    def check_oneof(cls, values):
        return cls._validate_field_groups(values)


default_message_pool.register_message("signalservice", "TextAttachment", TextAttachment)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class TextAttachmentGradient(betterproto2.Message):
    start_color: "typing.Annotated[int, pydantic.Field(ge=0, le=2**32 - 1)]" = (
        betterproto2.field(1, betterproto2.TYPE_UINT32)
    )
    """
    deprecated: this field will be removed in a future release.
    """

    end_color: "typing.Annotated[int, pydantic.Field(ge=0, le=2**32 - 1)]" = (
        betterproto2.field(2, betterproto2.TYPE_UINT32)
    )
    """
    deprecated: this field will be removed in a future release.
    """

    angle: "typing.Annotated[int, pydantic.Field(ge=0, le=2**32 - 1)]" = (
        betterproto2.field(3, betterproto2.TYPE_UINT32)
    )
    """
    degrees
    """

    colors: "list[typing.Annotated[int, pydantic.Field(ge=0, le=2**32 - 1)]]" = (
        betterproto2.field(4, betterproto2.TYPE_UINT32, repeated=True)
    )

    positions: "list[typing.Annotated[float, pydantic.AfterValidator(betterproto2.validators.validate_float32)]]" = betterproto2.field(
        5, betterproto2.TYPE_FLOAT, repeated=True
    )
    """
    percent from 0 to 1
    """


default_message_pool.register_message(
    "signalservice", "TextAttachment.Gradient", TextAttachmentGradient
)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class TypingMessage(betterproto2.Message):
    timestamp: "typing.Annotated[int, pydantic.Field(ge=0, le=2**64 - 1)]" = (
        betterproto2.field(1, betterproto2.TYPE_UINT64)
    )

    action: "TypingMessageAction" = betterproto2.field(
        2, betterproto2.TYPE_ENUM, default_factory=lambda: TypingMessageAction(0)
    )

    group_id: "bytes" = betterproto2.field(3, betterproto2.TYPE_BYTES)


default_message_pool.register_message("signalservice", "TypingMessage", TypingMessage)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class Verified(betterproto2.Message):
    destination_aci: "typing.Annotated[str, pydantic.AfterValidator(betterproto2.validators.validate_string)]" = betterproto2.field(
        5, betterproto2.TYPE_STRING
    )

    identity_key: "bytes" = betterproto2.field(2, betterproto2.TYPE_BYTES)

    state: "VerifiedState" = betterproto2.field(
        3, betterproto2.TYPE_ENUM, default_factory=lambda: VerifiedState(0)
    )

    null_message: "bytes" = betterproto2.field(4, betterproto2.TYPE_BYTES)

    destination_aci_binary: "bytes" = betterproto2.field(6, betterproto2.TYPE_BYTES)
    """
    16-byte UUID
    """


default_message_pool.register_message("signalservice", "Verified", Verified)
